# 问题描述：
当ai使用工具操作文件时，会出现这种情况
1. 聊天栏正常流式渲染
2. 编辑栏闪烁显示，文字统计数时大时小，且速度慢于聊天栏的工具内容

## 问题原因：
在于“获取原始文件内容”这个逻辑，每次接收到ai消息chunk时候，都会执行一遍
————导致大量请求需要排队，本地http速度再快，也架不住异步请求次数大

### 解决方案：
起初认为是useEffect的监听问题，于是将监听逻辑提取出来，作为一个独立的函数，直接供“发送消息”/“恢复中断”函数使用
后续定位到真正的问题后
修改逻辑为：首先检查backUp内有无内容，没有再去后端获取，获取后存入backUp
确保最多只有一次调用后端api获取文件内容。
第一次backUp没有数据 ——> 向后端请求 ——> 将输入填入backUp并返回结果
第二次backUp有数据 ——> 直接返回结果

### 碰到的问题：
1. 在fileToolHander.ts里无法直接使用useSelector，useDispatch ———— 自定义Hook解决
    **自定义 Hook 的定义**： 
        1.函数名必须以 `use` 开头（如 `useFileToolHandler`） 
        2. 可以在内部调用其他 React Hooks（如 `useSelector`、`useDispatch`、`useState` 等） 
        3.必须在 React组件或其他自定义 Hook 的顶层调用

2. 即使修复后的逻辑正确，但是每次调用processFileToolCalls，cachedContent始终为undefined
    - 原因： React Hook 闭包陷阱
        - editorState 是在 Hook 首次调用时通过 useSelector 获取的，之后即使 Redux 状态更新了，editorState 的值也不会更新
        - 每次调用 fetchFileContent 时，editorState 的值都是首次调用时的旧值，所以 cachedContent 始终为 undefined。

    - 解决方案：在 fetchFileContent 内部, 用useStore重新获取 editorState，而不是依赖闭包中的值。

    - 什么是闭包？
        - 函数可以记住它定义时所在作用域的变量。

    - useStore 是什么
        - useStore 返回 Redux store 对象本身，而 useSelector 返回的是当前时刻的状态值

    - ps: 其他类似情况：useEffect用于打印数据时，也用了useSelector来获取数据并console.log打印。这种情况能更新最新数据并打印。更多是依仗useEffect的依赖。 每次依赖变化时useSelector才能重新获取最新数据 ———— useSelector本身是不会随状态自动更新的


```ts
export const useFileToolHandler = () => {
  const dispatch = useDispatch();
  const editorState = useSelector((state: RootState) => state.tabSlice);

  const fetchFileContent = async (path: string): Promise<string> => {
    try {
      const cachedContent = editorState.backUp[path];
      console.log("你他妈到底是什么？", cachedContent,path) // 这里始终为undefined
      
      if (cachedContent !== undefined) {
        return cachedContent;
    //其他省略
```