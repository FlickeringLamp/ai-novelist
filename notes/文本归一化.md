文本归一化的作用
文本归一化是为了将不同形式的相同内容转换为统一的形式，提高匹配成功率。

具体例子
例子1：智能引号问题
# 原始文件中的内容
original = "Hello, world!"  # 普通引号

# AI生成的diff中的内容
search = "Hello, world!"     # 智能引号（左引号 " 和右引号 " 是不同的字符）

# 不归一化时
print(f"普通引号: {repr(original)}")  # 'Hello, world!'
print(f"智能引号: {repr(search)}")    # 'Hello, world!'
print(f"是否相同: {original == search}")  # False ❌ 匹配失败！

问题：虽然看起来一样，但它们是不同的字符，导致相似度计算失败。

归一化后：

# 归一化后
normalized_original = normalize_text(original)  # 'hello, world!'
normalized_search = normalize_text(search)      # 'hello, world!'
print(f"归一化后是否相同: {normalized_original == normalized_search}")  # True ✅ 匹配成功！

例子2：排版字符问题
# 原始文件中的省略号
original = "Loading..."  # 三个点

# AI生成的diff中的省略号
search = "Loading…"      # 一个Unicode省略号字符（U+2026）

# 不归一化时
print(f"三个点: {repr(original)}")  # 'Loading...'
print(f"一个省略号: {repr(search)}")  # 'Loading…'
print(f"是否相同: {original == search}")  # False ❌ 匹配失败！

归一化后：

# 归一化后
normalized_original = normalize_text(original)  # 'loading...'
normalized_search = normalize_text(search)      # 'loading...'
print(f"归一化后是否相同: {normalized_original == normalized_search}")  # True ✅ 匹配成功！

例子3：空格问题
# 原始文件中的内容
original = "Hello   World"  # 多个空格

# AI生成的diff中的内容
search = "Hello World"      # 一个空格

# 不归一化时
print(f"多个空格: {repr(original)}")  # 'Hello   World'
print(f"一个空格: {repr(search)}")    # 'Hello World'
print(f"是否相同: {original == search}")  # False ❌ 匹配失败！

归一化后：

# 归一化后
normalized_original = normalize_text(original)  # 'hello world'
normalized_search = normalize_text(search)      # 'hello world'
print(f"归一化后是否相同: {normalized_original == normalized_search}")  # True ✅ 匹配成功！

为什么会出现这些差异？
1. AI生成文本的特性
AI模型（如GPT、Claude）在生成文本时，会根据上下文使用"智能引号"
不同模型的文本生成策略不同，可能产生不同的字符
2. 编辑器和输入法
某些编辑器会自动将普通引号转换为智能引号
某些输入法会自动使用排版字符
3. 文件来源
从不同来源复制的文本可能包含不同的字符编码
